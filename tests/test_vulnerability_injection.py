"""
End-to-End Integration Tests for Vulnerability Detection

Tests real-world vulnerability patterns using:
- String reasoning
- Taint analysis
- Security predicates
- Entailment checking

Demonstrates Frame's capability to detect real security bugs.
"""

import pytest
from frame import EntailmentChecker, parse
from frame.lemmas.taint_lemmas import (
    taint_concat_left,
    sql_injection_pattern,
    xss_pattern,
    command_injection_pattern,
    sanitized_to_sink_safe,
    ALL_TAINT_LEMMAS
)


class TestSQLInjectionDetection:
    """Test SQL injection vulnerability detection"""

    def test_basic_sql_injection(self):
        """Test detecting basic SQL injection pattern"""
        checker = EntailmentChecker()

        # Vulnerable code pattern:
        # user_input = get_user_input()  # tainted
        # query = "SELECT * FROM users WHERE id=" + user_input
        # execute_sql(query)  # sink

        antecedent = parse(
            'source(user_input, "user") * '
            'taint(user_input) * '
            'query = "SELECT * FROM users WHERE id=" ++ user_input'
        )

        # Check if taint reaches SQL sink
        consequent = parse('taint(query)')

        result = checker.check_entailment(f"{antecedent} |- {consequent}")

        # Should prove that query is tainted via automatic taint propagation
        assert result.valid, "Should detect tainted query"

    def test_sql_injection_with_sink(self):
        """Test SQL injection with explicit sink"""
        checker = EntailmentChecker()

        # Pattern: tainted input flows to SQL sink
        formula = parse(
            'source(user_input, "user") * '
            'taint(user_input) * '
            'query = "SELECT * FROM users WHERE id=" ++ user_input * '
            'sink(query, "sql")'
        )

        # This formula should be satisfiable (vulnerability exists)
        # In incorrectness logic, we'd check SAT directly
        # For now, we just verify the formula parses and encodes correctly
        from frame.encoding.encoder import Z3Encoder
        encoder = Z3Encoder()
        z3_formula = encoder.encode_pure(formula)

        import z3
        solver = z3.Solver()
        solver.add(z3_formula)
        result = solver.check()

        # Should be satisfiable (vulnerability pattern exists)
        assert result == z3.sat, "SQL injection pattern should be satisfiable"

    def test_safe_parameterized_query(self):
        """Test that parameterized queries are safe"""
        checker = EntailmentChecker()

        # Safe pattern: sanitized input
        formula = parse(
            'source(user_input, "user") * '
            'clean = sanitize(user_input) * '
            'sanitized(clean) * '
            'query = "SELECT * FROM users WHERE id=" ++ clean * '
            'sink(query, "sql")'
        )

        # Sanitized data to sink should be safe
        from frame.encoding.encoder import Z3Encoder
        encoder = Z3Encoder()
        z3_formula = encoder.encode_pure(formula)

        import z3
        solver = z3.Solver()
        solver.add(z3_formula)
        result = solver.check()

        # Should be satisfiable (safe pattern exists)
        assert result == z3.sat

    def test_multiple_taint_sources(self):
        """Test SQL injection with multiple taint sources"""
        checker = EntailmentChecker()

        # Multiple inputs concatenated into query
        formula = parse(
            'source(name, "user") * '
            'source(email, "user") * '
            'taint(name) * '
            'taint(email) * '
            'query = "SELECT * FROM users WHERE name=" ++ name ++ " AND email=" ++ email * '
            'sink(query, "sql")'
        )

        from frame.encoding.encoder import Z3Encoder
        encoder = Z3Encoder()
        z3_formula = encoder.encode_pure(formula)

        import z3
        solver = z3.Solver()
        solver.add(z3_formula)

        assert solver.check() == z3.sat


class TestXSSDetection:
    """Test Cross-Site Scripting (XSS) vulnerability detection"""

    def test_basic_xss(self):
        """Test detecting basic XSS pattern"""
        # Vulnerable code:
        # user_input = get_user_input()
        # html = "<div>" + user_input + "</div>"
        # render(html)

        formula = parse(
            'source(user_input, "user") * '
            'taint(user_input) * '
            'html = "<div>" ++ user_input ++ "</div>" * '
            'sink(html, "html")'
        )

        from frame.encoding.encoder import Z3Encoder
        import z3

        encoder = Z3Encoder()
        z3_formula = encoder.encode_pure(formula)

        solver = z3.Solver()
        solver.add(z3_formula)

        assert solver.check() == z3.sat, "XSS pattern should be detectable"

    def test_xss_in_attribute(self):
        """Test XSS in HTML attribute"""
        formula = parse(
            'source(user_input, "user") * '
            'taint(user_input) * '
            'html = "<a href=\\"" ++ user_input ++ "\\">link</a>" * '
            'sink(html, "html")'
        )

        from frame.encoding.encoder import Z3Encoder
        import z3

        encoder = Z3Encoder()
        z3_formula = encoder.encode_pure(formula)

        solver = z3.Solver()
        solver.add(z3_formula)

        assert solver.check() == z3.sat

    def test_safe_html_with_escaping(self):
        """Test that escaped HTML is safe"""
        formula = parse(
            'source(user_input, "user") * '
            'escaped = escape_html(user_input) * '
            'sanitized(escaped) * '
            'html = "<div>" ++ escaped ++ "</div>" * '
            'sink(html, "html")'
        )

        from frame.encoding.encoder import Z3Encoder
        import z3

        encoder = Z3Encoder()
        z3_formula = encoder.encode_pure(formula)

        solver = z3.Solver()
        solver.add(z3_formula)

        # Safe pattern should be satisfiable
        assert solver.check() == z3.sat


class TestCommandInjectionDetection:
    """Test command injection vulnerability detection"""

    def test_basic_command_injection(self):
        """Test detecting command injection"""
        # Vulnerable code:
        # user_input = get_user_input()
        # cmd = "ls " + user_input
        # os.system(cmd)

        formula = parse(
            'source(user_input, "user") * '
            'taint(user_input) * '
            'cmd = "ls " ++ user_input * '
            'sink(cmd, "shell")'
        )

        from frame.encoding.encoder import Z3Encoder
        import z3

        encoder = Z3Encoder()
        z3_formula = encoder.encode_pure(formula)

        solver = z3.Solver()
        solver.add(z3_formula)

        assert solver.check() == z3.sat

    def test_safe_command_with_whitelist(self):
        """Test safe command execution with validated input"""
        formula = parse(
            'source(user_input, "user") * '
            'validated = validate_whitelist(user_input) * '
            'sanitized(validated) * '
            'cmd = "ls " ++ validated * '
            'sink(cmd, "shell")'
        )

        from frame.encoding.encoder import Z3Encoder
        import z3

        encoder = Z3Encoder()
        z3_formula = encoder.encode_pure(formula)

        solver = z3.Solver()
        solver.add(z3_formula)

        assert solver.check() == z3.sat


class TestPathTraversalDetection:
    """Test path traversal vulnerability detection"""

    def test_basic_path_traversal(self):
        """Test detecting path traversal"""
        # Vulnerable code:
        # user_input = get_user_input()
        # path = "/var/www/" + user_input
        # open(path)

        formula = parse(
            'source(user_input, "user") * '
            'taint(user_input) * '
            'path = "/var/www/" ++ user_input * '
            'sink(path, "filesystem")'
        )

        from frame.encoding.encoder import Z3Encoder
        import z3

        encoder = Z3Encoder()
        z3_formula = encoder.encode_pure(formula)

        solver = z3.Solver()
        solver.add(z3_formula)

        assert solver.check() == z3.sat

    def test_path_traversal_with_dotdot(self):
        """Test path traversal with '..' detection"""
        # Even more dangerous with '..'
        formula = parse(
            'source(user_input, "user") * '
            'taint(user_input) * '
            'path = "/var/www/" ++ user_input * '
            'path contains ".." * '
            'sink(path, "filesystem")'
        )

        from frame.encoding.encoder import Z3Encoder
        import z3

        encoder = Z3Encoder()
        z3_formula = encoder.encode_pure(formula)

        solver = z3.Solver()
        solver.add(z3_formula)

        assert solver.check() == z3.sat


